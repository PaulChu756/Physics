<!doctype html>
<html lang="en-us">
  <head>
    <title>Physics by PaulChu756</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">

    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | Physics</title>
    <link rel="stylesheet" href="TemplateData/style.css">
    <link rel="shortcut icon" href="TemplateData/favicon.ico" />
    <script src="TemplateData/UnityProgress.js"></script>
  </head>
  <body class="template">
    <p class="header"><span>Unity WebGL Player | </span>Physics</p>
    <div class="template-wrap clear">
    <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" height="600px" width="960px"></canvas>
      <div class="logo"></div>
      <div class="fullscreen"><img src="TemplateData/fullscreen.png" width="38" height="38" alt="Fullscreen" title="Fullscreen" onclick="SetFullscreen(1);" /></div>
      <div class="title">Physics</div>
    </div>
    <p class="footer">&laquo; created with <a href="http://unity3d.com/" title="Go to unity3d.com">Unity</a> &raquo;</p>
    <script type='text/javascript'>
  // connect to canvas
  var Module = {
    TOTAL_MEMORY: 268435456,
    filePackagePrefixURL: "Release/",
    memoryInitializerPrefixURL: "Release/",
    preRun: [],
    postRun: [],
    print: (function() {
      return function(text) {
        console.log (text);
      };
    })(),
    printErr: function(text) {
      console.error (text);
    },
    canvas: document.getElementById('canvas'),
    progress: null,
    setStatus: function(text) {
      if (this.progress == null) 
      {
        if (typeof UnityProgress != 'function')
          return;
        this.progress = new UnityProgress (canvas);
      }
      if (!Module.setStatus.last) Module.setStatus.last = { time: Date.now(), text: '' };
      if (text === Module.setStatus.text) return;
      this.progress.SetMessage (text);
      var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
      if (m)
        this.progress.SetProgress (parseInt(m[2])/parseInt(m[4]));
      if (text === "") 
        this.progress.Clear()
    },
    totalDependencies: 0,
    monitorRunDependencies: function(left) {
      this.totalDependencies = Math.max(this.totalDependencies, left);
      Module.setStatus(left ? 'Preparing... (' + (this.totalDependencies-left) + '/' + this.totalDependencies + ')' : 'All downloads complete.');
    }
  };
  Module.setStatus('Downloading (0.0/1)');
</script>
<script src="Release/UnityConfig.js"></script>
<script src="Release/fileloader.js"></script>
<script>if (!(!Math.fround)) {
  var script = document.createElement('script');
  script.src = "Release/Build.js";
  document.body.appendChild(script);
} else {
  var codeXHR = new XMLHttpRequest();
  codeXHR.open('GET', 'Release/Build.js', true);
  codeXHR.onload = function() {
    var code = codeXHR.responseText;
    if (!Math.fround) { 
try {
  console.log('optimizing out Math.fround calls');
  var m = /var ([^=]+)=global\.Math\.fround;/.exec(code);
  var minified = m[1];
  if (!minified) throw 'fail';
  var startAsm = code.indexOf('// EMSCRIPTEN_START_FUNCS');
  var endAsm = code.indexOf('// EMSCRIPTEN_END_FUNCS');
  var asm = code.substring(startAsm, endAsm);
  do {
    var moar = false; // we need to re-do, as x(x( will not be fixed
    asm = asm.replace(new RegExp('[^a-zA-Z0-9\\$\\_]' + minified + '\\(', 'g'), function(s) { moar = true; return s[0] + '(' });
  } while (moar);
  code = code.substring(0, startAsm) + asm + code.substring(endAsm);
  code = code.replace("'use asm'", "'almost asm'");
} catch(e) { console.log('failed to optimize out Math.fround calls ' + e) }
 }

    var blob = new Blob([code], { type: 'text/javascript' });
    codeXHR = null;
    var src = URL.createObjectURL(blob);
    var script = document.createElement('script');
    script.src = URL.createObjectURL(blob);
    script.onload = function() {
      URL.revokeObjectURL(script.src);
    };
    document.body.appendChild(script);
  };
  codeXHR.send(null);
}
</script>

      <section class="page-header">
          <h1 class="project-name">Physics</h1>
          <h2 class="project-tagline"></h2>
          <a href="https://github.com/PaulChu756/Physics" class="btn">View on GitHub</a>
          <a href="https://github.com/PaulChu756/Physics/zipball/master" class="btn">Download .zip</a>
          <a href="https://github.com/PaulChu756/Physics/tarball/master" class="btn">Download .tar.gz</a>
      </section>

      <section class="main-content">
          <p>
              <strong>Paul Chu</strong><br />
              <strong>AIE Year 2 Programming</strong><br />
              <strong>December 16th, 2015</strong>
          </p>

          <h1>
              <a id="i0-requirements-documentation" class="anchor" href="#i0-requirements-documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>I.0: Requirements Documentation</strong>
          </h1>

          <h2>
              <a id="i1-description-of-the-problem" class="anchor" href="#i1-description-of-the-problem" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>I.1: Description of the Problem</strong>
          </h2>

          <p>
              Name: Cloth Simulation
              Problem Statement: The physical simulation and will be used to demonstrate advanced physics interactions.
              Problem Specification:  The application uses a system of particles that interconnect with spring-dampers to make some type of cloth. In this cloth simulation we apply gravity to each particle, then apply and compute a force to each spring-damper. Then we compute and apply aerodynamic forces to each triangle upon the cloth. After all out of that, we integrate motion by applying a forward euler integration to each particle.
          </p>

          <h2>
              <a id="i2-input-information" class="anchor" href="#i2-input-information" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>I.2: Input Information</strong>
          </h2>

          <p>
              Name: Physics
              Description: Input of width and height of grid.
              Type: Unity/Visual Studio
              Range of Acceptable Values: Most acceptable values are 0 to 10, anything after would take a toll on user’s computer or tablet.
          </p>

          <h2>
              <a id="i3-output-information" class="anchor" href="#i3-output-information" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>I.3: Output Information</strong>
          </h2>

          <p>The program will output a cloth simulating a soft body physics.</p>

          <h2>
              <a id="i4-user-interface-information" class="anchor" href="#i4-user-interface-information" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>I.4: User Interface Information</strong>
          </h2>

          <p>
              A GUI will display for user after they input information. After, the user can increase/decrease values on via sliders displayed.
              The user can also spawn/reset the cloth simulation, also they can quit the application whenever they please.
          </p>

          <h1>
              <a id="ii0-design-documentation" class="anchor" href="#ii0-design-documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>II.0: Design Documentation</strong>
          </h1>

          <h2>
              <a id="ii1-system-architecture-description" class="anchor" href="#ii1-system-architecture-description" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>II.1: System Architecture Description</strong>
          </h2>

          <p>
              The program is split into five different scripts for organization. The main script in this project is Spawner.cs, this is the main part of the project, it handles line rendering for springs, spawning/resetting the cloth, pinning the corners for the grid, and exiting.

              <h2>
                  <a id="ii1-Information-about-the-functions" class="anchor" href="#ii1-Information-about-the-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>II.2: Information about the functions</strong>
              </h2>

              File: Spawner.cs<br />
              Class:Spawner<br />
              Data Members: MonoBehaviour
          </p>

          <p>
              Name: particles<br />
              Description: A list of class Particle
          </p>

          <p>
              Name: springs<br />
              Description: A list of class Spring
          </p>

          <p>
              Name: triangles<br />
              Description: A list of class AeroForce
          </p>

          <p>
              Name: particle<br />
              Description: A class Particle gameobject
          </p>

          <p>
              Name: spring<br />
              Description: A class Spring gameobject
          </p>

          <p>
              Name: triangle<br />
              Description: A class Aeroforce gameobject
          </p>

          <p>
              Name: width<br />
              Description: a public integer for user to define width of cloth
          </p>

          <p>
              Name: height<br />
              Description: a public integer of user to define height of cloth
          </p>

          <p>
              Name: vLim<br />
              Description: a public float to limit velocity so it doesn’t cause errors.
          </p>

          <p>
              Name: k<br />
              Description: spring force variable to increase/decrease slider value.
          </p>

          <p>
              Name: b<br />
              Description: damping force variable to increase/decrease slider value for spring stiffness.
          </p>

          <p>
              Name: l<br />
              Description: rest length variable to increase/decrease slider value for distance between particles.
          </p>

          <p>
              Name: air<br />
              Description: air variable to increase/decrease slider value to blow onto cloth.
          </p>

          <p>
              Function: FixedUpdate<br />
              Description: Computes and applies force to particle, spring, triangle and does the euler integration.
          </p>

          <p>
              Function: Update<br />
              Description: Updates all line rendering to each particle 1 to particle 2, and also checks if Esc or P is pressed to exit the program.
          </p>

          <p>
              Function: ResetCloth<br />
              Description: Destroys each particle, spring, and triangle, also the lists for all of them. Reset values on sliders and create new list of particles, spring, and triangles and call Spawn function to create Cloth, along with anchors at corners.
          </p>

          <p>
              Function: isPinned<br />
              Description: Pins all the particles at the corners of the cloth.
          </p>

          <p>
              Function: Exit<br />
              Description: Exit application.
          </p>

          <p>
              Function: Spawn<br />
              Parameters: n/a<br />
              Description: It creates all particles in a 2D grid format, while we create the particles, springs connect to the previous particle that is created. So as the particles on the width are created, it connects a spring going to the left. Particles created on the height, are connected by going downward. After this, for diagonal, it goes left and right downward diagonal to connect as the grid is created. As the grid is created into a square like object, we cut those squares into triangles so we can use these triangles for Aerodynamic forces.
          </p>

          <p>
              File: Particle<br />
              Class: Particle<br />
              Data Members: MonoBehaviour
          </p>

          <p>
              Name: position<br />
              Description: Getting and setting the position = transform.position
          </p>

          <p>
              Name: velocity<br />
              Description: current velocity of the particle
          </p>

          <p>
              Name: force<br />
              Description: the current force applied to the particle
          </p>

          <p>
              Name: mass<br />
              Description: the current mass the particle has.
          </p>

          <p>
              Name: isPinned<br />
              Description: if the particle is pinned or not.
          </p>

          <p>
              Function: Awake<br />
              Description: setting the current particle’s position to the transform.position which is the current gameobject.
          </p>

          <p>
              Function: ParticleMath<br />
              Description: Euler Integration upon particle, does acceleration = f / m; also velocity += (acceleration * deltaTime), position += (velocity * deltaTime);
          </p>

          <p>
              File: Spring<br />
              Class: Spring<br />
              Data Members: MonoBehaviour
          </p>

          <p>
              Name: springConstant<br />
              Description: A a constant for how strong the spring is
          </p>

          <p>
              Name: dampingFactor<br />
              Description: A constant for slowing down motion of the spring
          </p>

          <p>
              Name: RestLength<br />
              Description: The distance between two particles

              Name: Particle<br />
              Description: p1 and p2
          </p>

          <p>
              Function: makeSpring<br />
              Parameters: Particle p1, Particle p2<br />
              Description: To connect the new particle that is created to the previous one
          </p>

          <p>
              Function: ComputeForce<br />
              Description: First we get the distance between p2 pos and p1 pos. Then we normalized e (distance between p2 pos and p1), then use the distance formula between them. After getting the length between them we use an equation to get Spring force. After that we get the linear damping force, after this, we turned all the 3D distances &amp; velocities to 1D. We compute spring back to 1D, and then turn that 1D force back into 3D force. After that we get spring damper by just adding spring force and damping force together. Then we find the 1D force and turn it back into 3D, and just add it to p1.force and p2.force.
          </p>

          <p>
              File: AeroForce<br />
              Class: AeroForce<br />
              Data Members: MonoBehaviour
          </p>

          <p>
              Name: Particle<br />
              Description: Particles name p1, p2 ,p3
          </p>

          <p>
              Name: velAir<br />
              Description: A force that applies itself on the cloth to make it appear wind or water.
          </p>

          <p>
              Name: drag<br />
              Description: Air resistance
          </p>

          <p>
              Name: Density<br />
              Description: The mass per volume of the velAir.
          </p>

          <p>
              Function: makeTriangle<br />
              Description: To connect Particle p1, p2, p3 all together to form a triangle.
          </p>

          <p>
              Function: AeroMath<br />
              Description: First we find the velocity of the triangle. Then we subtract velTriangle by air velocity. Then we find the normal of the triangle, by doing a lot of math. After a lot of math, we use the Aerodyamic force equation which applies a force to each triangle that is on the cloth.
          </p>

          <p>
              File:SetText<br />
              Class:SetText<br />
              Data Members: MonoBehaviour
          </p>

          <p>
              Function: SetLabel<br />
              Parameters(Slider slider)<br />
              Description: The slider that is passed in, will turn it’s slider value to a string, to display the number it’s on.
          </p>

          <p>
              File: DragObject<br />
              Class:DragObject<br />
              Data Members: MonoBehaviour
          </p>

          <p>
              Name: screenPoint<br />
              Description: It grabs the particle’s position from world to screen point
          </p>

          <p>
              Name: offset<br />
              Description: Calculate any difference between the particle world position and the mouse's Screen position converted to a world point.
          </p>

          <p>
              Function: OnMouseDown<br />
              Description: Once the left mouse button is pressed, the user can grab the particle, and move it around.
          </p>

          <p>
              Function: OnMouseDrag<br />
              Description: The user can now drag the particle around the screen while keeping track of it in world space as the user inputs through screen space.
          </p>

          <h1>
              <a id="iii0-implementation-documentation" class="anchor" href="#iii0-implementation-documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>III.0: Implementation Documentation</strong>
          </h1>

          <h2>
              <a id="iii1-program-code" class="anchor" href="#iii1-program-code" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>III.1 Program Code</strong>
          </h2>

          <h1>
              <a id="file-spawnercs" class="anchor" href="#file-spawnercs" aria-hidden="true"><span class="octicon octicon-link"></span></a>File: Spawner.cs
          </h1>

<pre><code>using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;
public class Spawner : MonoBehaviour
{
    public List particles = new List();
    public List springs = new List();
    public List triangles = new List();
    public Particle particle;
    public Spring spring;
    public AeroForce triangle;
    public int width, height;
    public float vLim;
    public Slider k, b, l, air, width_, height_;
    public Button exit, spawn;
    GameObject particles_;
    GameObject springs_;
    GameObject triangle_;
void FixedUpdate()
{
    foreach (Particle p in particles)
    {
        p.force = new Vector3(0, -9.8f, 0) * p.mass;
        if(p.velocity.magnitude &gt; vLim)
        {
           p.velocity = p.velocity.normalized * vLim;
        }
    }
    foreach (Spring s in springs)
    {
        if (s != null)
        {
            s.springConstant = k.value;
            s.dampingFactor = b.value;
            s.RestLength = l.value;
            s.GetComponent&lt;Spring&gt;().ComputeForce();
        }
    }
    foreach (AeroForce t in triangles)
    {
        if(t != null)
        {
            t.velAir.z = air.value;
            t.GetComponent&lt;AeroForce&gt;().AeroMath();
        }
    }
    foreach (Particle p in particles) // Particle Euler Intergration
    {
        if(p != null)
        {
            p.GetComponent&lt;Particle&gt;().ParticleMath();
        }
    }
}
// Loops through spring list to draw lines to each particle
void Update()
{
    int i = 0;
    foreach (Spring s in springs)
    {
        if (s != null)
        {
            // Credit: Matthew Williamson
            LineRenderer l = s.GetComponent&lt;LineRenderer&gt;();
            l.SetPosition(0, springs[i].p1.transform.position);
            l.SetPosition(1, springs[i].p2.transform.position);
            i++;
        }
    }
    if (Input.GetKey(KeyCode.Escape) || Input.GetKey(KeyCode.P))
    {
        Exit();
    }
}
public void ResetCloth()
{
    foreach(Particle p in particles)
    {
        Destroy(p.gameObject);
    }
    foreach (Spring s in springs)
    {
        Destroy(s.gameObject);
    }
    foreach(AeroForce t in triangles)
    {
        Destroy(t.gameObject);
    }
    Destroy(particles_);
    Destroy(springs_);
    Destroy(triangle_);
    k.value = 1;
    b.value = 1;
    l.value = 1;
    air.value = 0.1f;
    particles = new List&lt;Particle&gt;();
    springs = new List&lt;Spring&gt;();
    triangles = new List&lt;AeroForce&gt;();
    width = (int)width_.value;
    height = (int)height_.value;
    Spawn();
    isPinned();
}
public void isPinned()
{
    // If Width and Height are the same numbers
    particles[width - 1].isPinned = true; // Bottom right
    particles[height * width - 1].isPinned = true; // Top right
    particles[height * width - width].isPinned = true; // Top left
    particles[0].isPinned = true; // Bottom Left
}
public void Exit()
{
    Application.Quit();
}
public void Spawn()
{
    particles_ = new GameObject();
    springs_ = new GameObject();
    triangle_ = new GameObject();
    particles_.name = "Particles";
    particles_.transform.SetParent(transform);
    springs_.name = "Springs";
    springs_.transform.SetParent(transform);
    triangle_.name = "Triangles";
    triangle_.transform.SetParent(transform);
    for (int y = 0; y &lt; height; y++)
    {
        for (int x = 0; x &lt; width; x++)
        {
            Particle newParticle = Instantiate(particle);
            newParticle.transform.position = new Vector3(x * width, y * height, 0);
            newParticle.name = x.ToString() + " " + y.ToString(); // Set all particle clone names into numbers
            newParticle.transform.SetParent(particles_.transform);
            particles.Add(newParticle);
            if (x &gt; 0) // Left spring
            {
                // Make sure this isn't the first particle in the row, if there is, there won't be anything to it's left and we can't connect.
                //connects to the part we just created with the particle at the index.
                // particle at the same Y value.
                // x - 1 we're creating all the particles one by one, but storing.
                Spring sideSpring = Instantiate(spring);
                LineRenderer l = sideSpring.GetComponent&lt;LineRenderer&gt;();
                l.SetPosition(0, newParticle.transform.position);
                l.SetPosition(1, particles[y * width + (x - 1)].transform.position);
                sideSpring.name = "SideSpring: " + x.ToString() + " " + y.ToString();
                sideSpring.makeSpring(newParticle, particles[y * width + (x - 1)]);
                springs.Add(sideSpring);
                sideSpring.transform.SetParent(springs_.transform);
            }
            if (y &gt; 0) // Up Spring
            {
                //// Connecting ontop, but going downwards.
                Spring aboveSpring = Instantiate(spring);
                LineRenderer l = aboveSpring.GetComponent&lt;LineRenderer&gt;();
                l.SetPosition(0, newParticle.transform.position);
                l.SetPosition(1, particles[(y - 1) * width + x].transform.position);
                aboveSpring.name = "AboveSpring: " + x.ToString() + " " + y.ToString();
                aboveSpring.makeSpring(newParticle, particles[(y - 1) * width + x]);
                springs.Add(aboveSpring);
                aboveSpring.transform.SetParent(springs_.transform);
            }
            if (x &gt; 0 &amp;&amp; y &gt; 0) // DownLeftDiagonal spring y-1, x-1
            {
                Spring downLeftSpring = Instantiate(spring);
                LineRenderer l = downLeftSpring.GetComponent&lt;LineRenderer&gt;();
                l.SetPosition(0, newParticle.transform.position);
                l.SetPosition(1, particles[(y - 1) * width + (x - 1)].transform.position);
                downLeftSpring.name = "UpLeftSpring: " + x.ToString() + " " + y.ToString();
                downLeftSpring.makeSpring(newParticle, particles[(y - 1) * width + (x - 1)]);
                springs.Add(downLeftSpring);
                downLeftSpring.transform.SetParent(springs_.transform);
            }
            if (x &lt; width - 1 &amp;&amp; y &gt; 0) // DownRightDiagonal, spring y-1, x+1
            {
                Spring downRightSpring = Instantiate(spring);
                LineRenderer l = downRightSpring.GetComponent&lt;LineRenderer&gt;();
                l.SetPosition(0, newParticle.transform.position);
                l.SetPosition(1, particles[(y - 1) * width + (x + 1)].transform.position);
                downRightSpring.name = "DownRightSpring: " + x.ToString() + " " + y.ToString();
                downRightSpring.makeSpring(newParticle, particles[(y - 1) * width + (x + 1)]);
                springs.Add(downRightSpring);
                downRightSpring.transform.SetParent(springs_.transform);
            }
        }
    }
    // Credit: Matthew Williamson
    for(int x = 0; x &lt; particles.Count; x++)
    {
        if (x + 1 &lt; width * height &amp;&amp; x + width &lt; width * height &amp;&amp; x + width + 1 &lt; width * height)
        {
            AeroForce firstTri = Instantiate(triangle);
            firstTri.name = "FirstTriangle: " + width.ToString() + " " + height.ToString();
            firstTri.makeTriangle(particles[x], particles[x + 1], particles[x + width]);
            triangles.Add(firstTri);
            firstTri.transform.SetParent(triangle_.transform);
            AeroForce secondTri = Instantiate(triangle);
            secondTri.name = "SecondTriangle: " + width.ToString() + " " + height.ToString();
            secondTri.makeTriangle(particles[x], particles[x + 1], particles[x + width + 1]);
            triangles.Add(secondTri);
            secondTri.transform.SetParent(triangle_.transform);
            AeroForce thirdTri = Instantiate(triangle);
            thirdTri.name = "ThirdTriangle: " + width.ToString() + " " + height.ToString();
            thirdTri.makeTriangle(particles[x + 1], particles[x + width], particles[x + width + 1]);
            triangles.Add(thirdTri);
            thirdTri.transform.SetParent(triangle_.transform);
            AeroForce fourthTri = Instantiate(triangle);
            fourthTri.name = "FourthTriangle: " + width.ToString() + " " + height.ToString();
            fourthTri.makeTriangle(particles[x], particles[x + width], particles[x + width + 1]);
            triangles.Add(fourthTri);
            fourthTri.transform.SetParent(triangle_.transform);
        }
    }
}
}
</code></pre>

          <h1>
              <a id="file-particlecs" class="anchor" href="#file-particlecs" aria-hidden="true"><span class="octicon octicon-link"></span></a>File: Particle.cs
          </h1>

<pre><code>class Particle: 
using UnityEngine;
using System.Collections;
public class Particle : MonoBehaviour
{
    public Vector3 position // current pos of the particle in space
    {
        get { return transform.position; }
        set { transform.position = value; } // Getting and Setting the position = transform.position
    }
    public Vector3 velocity; // current velocity of the particle
    public Vector3 force;
    public float mass;
    public bool isPinned;
void Awake()
{
    position = transform.position;
}
public void ParticleMath()
{
    if (!isPinned)
    {
        Vector3 acceleration = force / mass; // We create acceleration right here, so it doesn't get reset
        velocity += (acceleration * Time.deltaTime);
        position += (velocity * Time.deltaTime);
    }
}
}
</code></pre>

          <h1>
              <a id="file-springcs" class="anchor" href="#file-springcs" aria-hidden="true"><span class="octicon octicon-link"></span></a>File: Spring.cs
          </h1>

<pre><code>class Spring: 
using UnityEngine;
using System.Collections;
public class Spring : MonoBehaviour
{
    public float springConstant;
    public float dampingFactor;
    public float RestLength;
    public Particle p1, p2;
public void makeSpring(Particle P1, Particle P2)
{
    p1 = P1;
    p2 = P2;
}
public void ComputeForce()
{
    // Credit: Matthew Williamson.
    Vector3 e = p2.position - p1.position;
    Vector3 l = e.normalized;
    float distanceBetween = Vector3.Distance(p1.position, p2.position);
    float forceSpring = -springConstant * (RestLength - distanceBetween);
    float v1 = Vector3.Dot(l, p1.velocity);
    float v2 = Vector3.Dot(l, p2.velocity);
    float dampingForce = -dampingFactor * (v1 - v2);
    float springDamper = forceSpring + dampingForce;
    Vector3 force1 = springDamper * l;
    Vector3 force2 = -force1;
    p1.force += force1;
    p2.force += force2;
}
}
</code></pre>

          <h1>
              <a id="file-aeroforcecs" class="anchor" href="#file-aeroforcecs" aria-hidden="true"><span class="octicon octicon-link"></span></a>File: AeroForce.cs
          </h1>

<pre><code>using UnityEngine;
using System.Collections;
public class AeroForce : MonoBehaviour
{
    Particle p1, p2, p3;
    public Vector3 velAir = new Vector3 (0, 0, 0);
    public float drag = 0.5f;
    public float density = 1.0f;
public void makeTriangle(Particle P1, Particle P2, Particle P3)
{
    p1 = P1;
    p2 = P2;
    p3 = P3;
}
public void AeroMath()
{
    // Credit: Matthew Willson &amp;&amp; Andrew Gotow.
    //Find velocity of Triangle.
    Vector3 velTriangle = (p1.velocity + p2.velocity + p3.velocity) / 3;
    //Find relative velocity, so subtract off velocity of the air.
    velTriangle -= velAir;
    //Finding the normal of the Triangle.
    Vector3 a = p2.position - p1.position;
    Vector3 b = p3.position - p1.position;
    Vector3 crossProduct = Vector3.Cross(a,b);
    Vector3 normalTri = crossProduct / crossProduct.magnitude;
    float totalArea = 0.5f * crossProduct.magnitude;
    float effectiveArea = totalArea * Vector3.Dot(velTriangle, normalTri) / velTriangle.magnitude;
    // Aerodyamic Force equation
    // AeroForce = -0.5 * density * drag * area * |V|^2 * normalTri
    Vector3 aeroForce = -0.5f * drag * density * effectiveArea * velTriangle.sqrMagnitude * normalTri;
    aeroForce /= 3.0f;
    p1.force += aeroForce;
    p2.force += aeroForce;
    p3.force += aeroForce;
}
}
</code></pre>

          <h1>
              <a id="file-dragobjectcs" class="anchor" href="#file-dragobjectcs" aria-hidden="true"><span class="octicon octicon-link"></span></a>File: DragObject.cs
          </h1>

<pre><code>using UnityEngine;
using System.Collections;
public class DragObject : MonoBehaviour
{
    private Vector3 screenPoint;
    private Vector3 offset;
private void OnMouseDown()
{
    //translate the particle position from the world to Screen Point
    screenPoint = Camera.main.WorldToScreenPoint(gameObject.transform.position);
    //calculate any difference between the particle world position and the mouses Screen position converted to a world point  
    offset = gameObject.transform.position - Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, screenPoint.z));
}
private void OnMouseDrag()
{
    //keep track of the mouse position
    Vector3 currentScreenPoint = new Vector3(Input.mousePosition.x, Input.mousePosition.y, screenPoint.z);
    //convert the screen mouse position to world point and adjust with offset
    Vector3 currentPosition = Camera.main.ScreenToWorldPoint(currentScreenPoint) + offset;
    //update the position of the object in the world
    transform.position = currentPosition;
}
}
</code></pre>


          <h1>
              <a id="file-settextcs" class="anchor" href="#file-settextcs" aria-hidden="true"><span class="octicon octicon-link"></span></a>File: SetText.cs
          </h1>

<pre><code>using UnityEngine;
using UnityEngine.UI;
public class SetText : MonoBehaviour
{
    public void SetLabel(Slider slider)
    {
        gameObject.GetComponent().text = slider.value.ToString();
    }
}
</code></pre>

          <p>
              IV.2: Operating Directions<br />
              To run this program, navigate through directory and click on build.exe or go to <a href="http://paulchu756.github.io/Physics/">http://paulchu756.github.io/Physics/</a>  (Please make sure you have build data folder with it).
          </p>

          <p>
              V.0: Instructions Directions<br />
              Left click: drag particles around in the scence.<br />
              Right Click: rotate the camera on any axis(It is slow). <br />
              Middle Mouse Button: To translate on x and y axis.
          </p>

          <footer class="site-footer">
              <span class="site-footer-owner"><a href="https://github.com/PaulChu756/Physics">Physics</a> is maintained by <a href="https://github.com/PaulChu756">PaulChu756</a>.</span>

              <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
          </footer>
      </section>
  </body>
</html>
