{"name":"Physics","tagline":"","body":"**Paul Chu**\r\n**AIE Year 2 Programming**\r\n**December 16th, 2015**\r\n\r\n#**I.0: Requirements Documentation**\r\n##**I.1: Description of the Problem**\r\nName: Cloth Simulation \r\nProblem Statement: The physical simulation and will be used to demonstrate advanced physics interactions.\r\nProblem Specification:  The application uses a system of particles that interconnect with spring-dampers to make some type of cloth. In this cloth simulation we apply gravity to each particle, then apply and compute a force to each spring-damper. Then we compute and apply aerodynamic forces to each triangle upon the cloth. After all out of that, we integrate motion by applying a forward euler integration to each particle.\r\n\r\n##**I.2: Input Information**\r\nName: Physics\r\nDescription: Input of width and height of grid.\r\nType: Unity/Visual Studio\r\nRange of Acceptable Values: Most acceptable values are 0 to 10, anything after would take a toll on user’s computer or tablet.\r\n\r\n##**I.3: Output Information**\r\nThe program will output a cloth simulating a soft body physics.\r\n\r\n##**I.4: User Interface Information**\r\nA GUI will display for user after they input information. After, the user can increase/decrease values on via sliders displayed. \r\nThe user can also spawn/reset the cloth simulation, also they can quit the application whenever they please.\r\n\r\n#**II.0: Design Documentation**\r\n##**II.1: System Architecture Description**\r\nThe program is split into five different scripts for organization. The main script in this project is Spawner.cs, this is the main part of the project, it handles line rendering for springs, spawning/resetting the cloth, pinning the corners for the grid, and exiting.\r\nII.2: Information about the functions\r\nFile: Spawner.cs\r\nClass:Spawner\r\nData Members: MonoBehaviour\r\n\r\nName: particles\r\nDescription: A list of class Particle\r\n\r\nName: springs\r\nDescription: A list of class Spring\r\n\r\nName: triangles\r\nDescription: A list of class AeroForce\r\n\r\nName: particle\r\nDescription: A class Particle gameobject\r\n\r\nName: spring\r\nDescription: A class Spring gameobject\r\n\r\nName: triangle\r\nDescription: A class Aeroforce gameobject\r\n\r\nName: width\r\nDescription: a public integer for user to define width of cloth\r\n\r\nName: height\r\nDescription: a public integer of user to define height of cloth\r\n\r\nName: vLim\r\nDescription: a public float to limit velocity so it doesn’t cause errors.\r\n\r\nName: k\r\nDescription: spring force variable to increase/decrease slider value.\r\n\r\nName: b\r\nDescription: damping force variable to increase/decrease slider value for spring stiffness.\r\n\r\nName: l\r\nDescription: rest length variable to increase/decrease slider value for distance between particles.\r\n\r\nName: air\r\nDescription: air variable to increase/decrease slider value to blow onto cloth.\r\n\r\nFunction: FixedUpdate\r\nDescription: Computes and applies force to particle, spring, triangle and does the euler integration. \r\n\r\nFunction: Update\r\nDescription: Updates all line rendering to each particle 1 to particle 2, and also checks if Esc or P is pressed to exit the program.\r\n\r\nFunction: ResetCloth\r\nDescription: Destroys each particle, spring, and triangle, also the lists for all of them. Reset values on sliders and create new list of particles, spring, and triangles and call Spawn function to create Cloth, along with anchors at corners.\r\n\r\nFunction: isPinned\r\nDescription: Pins all the particles at the corners of the cloth.\r\n\r\nFunction: Exit\r\nDescription: Exit application.\r\n\r\nFunction: Spawn\r\nParameters: n/a\r\nDescription: It creates all particles in a 2D grid format, while we create the particles, springs connect to the previous particle that is created. So as the particles on the width are created, it connects a spring going to the left. Particles created on the height, are connected by going downward. After this, for diagonal, it goes left and right downward diagonal to connect as the grid is created. As the grid is created into a square like object, we cut those squares into triangles so we can use these triangles for Aerodynamic forces. \r\n\r\nFile: Particle\r\nClass: Particle\r\nData Members: MonoBehaviour\r\n\r\nName: position\r\nDescription: Getting and setting the position = transform.position \r\n\r\nName: velocity\r\nDescription: current velocity of the particle\r\n\r\nName: force\r\nDescription: the current force applied to the particle\r\n\r\nName: mass\r\nDescription: the current mass the particle has.\r\n\r\nName: isPinned\r\nDescription: if the particle is pinned or not.\r\n\r\nFunction: Awake\r\nDescription: setting the current particle’s position to the transform.position which is the current gameobject.\r\n\r\nFunction: ParticleMath\r\nDescription: Euler Integration upon particle, does acceleration = f / m; also velocity += (acceleration * deltaTime), position += (velocity * deltaTime);\r\n\r\nFile: Spring\r\nClass: Spring\r\nData Members: MonoBehaviour\r\n\r\nName: springConstant\r\nDescription: A a constant for how strong the spring is\r\n\r\nName: dampingFactor\r\nDescription: A constant for slowing down motion of the spring\r\n\r\nName: RestLength\r\nDescription: The distance between two particles\r\nName: Particle\r\nDescription: p1 and p2\r\n\r\nFunction: makeSpring\r\nParameters: Particle p1, Particle p2\r\nDescription: To connect the new particle that is created to the previous one\r\n\r\nFunction: ComputeForce\r\nDescription: First we get the distance between p2 pos and p1 pos. Then we normalized e (distance between p2 pos and p1), then use the distance formula between them. After getting the length between them we use an equation to get Spring force. After that we get the linear damping force, after this, we turned all the 3D distances & velocities to 1D. We compute spring back to 1D, and then turn that 1D force back into 3D force. After that we get spring damper by just adding spring force and damping force together. Then we find the 1D force and turn it back into 3D, and just add it to p1.force and p2.force.\r\n\r\nFile: AeroForce\r\nClass: AeroForce\r\nData Members: MonoBehaviour\r\n\r\nName: Particle\r\nDescription: Particles name p1, p2 ,p3\r\n\r\nName: velAir\r\nDescription: A force that applies itself on the cloth to make it appear wind or water. \r\n\r\nName: drag\r\nDescription: Air resistance \r\n\r\nName: Density\r\nDescription: The mass per volume of the velAir.\r\n\r\nFunction: makeTriangle\r\nDescription: To connect Particle p1, p2, p3 all together to form a triangle.\r\n\r\nFunction: AeroMath\r\nDescription: First we find the velocity of the triangle. Then we subtract velTriangle by air velocity. Then we find the normal of the triangle, by doing a lot of math. After a lot of math, we use the Aerodyamic force equation which applies a force to each triangle that is on the cloth.\r\n\r\nFile:SetText\r\nClass:SetText\r\nData Members: MonoBehaviour\r\n\r\nFunction: SetLabel\r\nParameters(Slider slider)\r\nDescription: The slider that is passed in, will turn it’s slider value to a string, to display the number it’s on.\r\n\r\nFile: DragObject\r\nClass:DragObject\r\nData Members: MonoBehaviour\r\n\r\nName: screenPoint\r\nDescription: It grabs the particle’s position from world to screen point\r\n\r\nName: offset\r\nDescription: Calculate any difference between the particle world position and the mouse's Screen position converted to a world point.\r\n\r\nFunction: OnMouseDown\r\nDescription: Once the left mouse button is pressed, the user can grab the particle, and move it around.\r\n\r\nFunction: OnMouseDrag\r\nDescription: The user can now drag the particle around the screen while keeping track of it in world space as the user inputs through screen space.\r\n\r\n#**III.0: Implementation Documentation**\r\n##**III.1 Program Code**\r\n#File: Spawner.cs\r\nusing UnityEngine;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine.UI;\r\n\r\npublic class Spawner : MonoBehaviour\r\n{\r\n    public List<Particle> particles = new List<Particle>();\r\n    public List<Spring> springs = new List<Spring>();\r\n    public List<AeroForce> triangles = new List<AeroForce>();\r\n    public Particle particle;\r\n    public Spring spring;\r\n    public AeroForce triangle;\r\n    public int width, height;\r\n    public float vLim;\r\n    public Slider k, b, l, air, width_, height_;\r\n    public Button exit, spawn;\r\n    GameObject particles_;\r\n    GameObject springs_;\r\n    GameObject triangle_;\r\n\r\n    void FixedUpdate()\r\n    {\r\n        foreach (Particle p in particles)\r\n        {\r\n            p.force = new Vector3(0, -9.8f, 0) * p.mass;\r\n            if(p.velocity.magnitude > vLim)\r\n            {\r\n               p.velocity = p.velocity.normalized * vLim;\r\n            }\r\n        }\r\n\r\n        foreach (Spring s in springs)\r\n        {\r\n            if (s != null)\r\n            {\r\n                s.springConstant = k.value;\r\n                s.dampingFactor = b.value;\r\n                s.RestLength = l.value;\r\n                s.GetComponent<Spring>().ComputeForce();\r\n            }\r\n        }\r\n\r\n        foreach (AeroForce t in triangles)\r\n        {\r\n            if(t != null)\r\n            {\r\n                t.velAir.z = air.value;\r\n                t.GetComponent<AeroForce>().AeroMath();\r\n            }\r\n        }\r\n\r\n        foreach (Particle p in particles) // Particle Euler Intergration\r\n        {\r\n            if(p != null)\r\n            {\r\n                p.GetComponent<Particle>().ParticleMath();\r\n            }\r\n        }\r\n    }\r\n\r\n    // Loops through spring list to draw lines to each particle\r\n    void Update()\r\n    {\r\n        int i = 0;\r\n        foreach (Spring s in springs)\r\n        {\r\n            if (s != null)\r\n            {\r\n                // Credit: Matthew Williamson\r\n                LineRenderer l = s.GetComponent<LineRenderer>();\r\n                l.SetPosition(0, springs[i].p1.transform.position);\r\n                l.SetPosition(1, springs[i].p2.transform.position);\r\n                i++;\r\n            }\r\n        }\r\n\r\n        if (Input.GetKey(KeyCode.Escape) || Input.GetKey(KeyCode.P))\r\n        {\r\n            Exit();\r\n        }\r\n    }\r\n\r\n    public void ResetCloth()\r\n    {\r\n        foreach(Particle p in particles)\r\n        {\r\n            Destroy(p.gameObject);\r\n        }\r\n\r\n        foreach (Spring s in springs)\r\n        {\r\n            Destroy(s.gameObject);\r\n        }\r\n\r\n        foreach(AeroForce t in triangles)\r\n        {\r\n            Destroy(t.gameObject);\r\n        }\r\n\r\n        Destroy(particles_);\r\n        Destroy(springs_);\r\n        Destroy(triangle_);\r\n\r\n        k.value = 1;\r\n        b.value = 1;\r\n        l.value = 1;\r\n        air.value = 0.1f;\r\n\r\n        particles = new List<Particle>();\r\n        springs = new List<Spring>();\r\n        triangles = new List<AeroForce>();\r\n\r\n        width = (int)width_.value;\r\n        height = (int)height_.value;\r\n        Spawn();\r\n        isPinned();\r\n    }\r\n\r\n    public void isPinned()\r\n    {\r\n        // If Width and Height are the same numbers\r\n        particles[width - 1].isPinned = true; // Bottom right\r\n        particles[height * width - 1].isPinned = true; // Top right\r\n        particles[height * width - width].isPinned = true; // Top left\r\n        particles[0].isPinned = true; // Bottom Left\r\n    }\r\n\r\n    public void Exit()\r\n    {\r\n        Application.Quit();\r\n    }\r\n\r\n    public void Spawn()\r\n    {\r\n        particles_ = new GameObject();\r\n        springs_ = new GameObject();\r\n        triangle_ = new GameObject();\r\n\r\n        particles_.name = \"Particles\";\r\n        particles_.transform.SetParent(transform);\r\n\r\n        springs_.name = \"Springs\";\r\n        springs_.transform.SetParent(transform);\r\n\r\n        triangle_.name = \"Triangles\";\r\n        triangle_.transform.SetParent(transform);\r\n\r\n        for (int y = 0; y < height; y++)\r\n        {\r\n            for (int x = 0; x < width; x++)\r\n            {\r\n                Particle newParticle = Instantiate(particle);\r\n                newParticle.transform.position = new Vector3(x * width, y * height, 0);\r\n                newParticle.name = x.ToString() + \" \" + y.ToString(); // Set all particle clone names into numbers\r\n                newParticle.transform.SetParent(particles_.transform);\r\n                particles.Add(newParticle);\r\n\r\n                if (x > 0) // Left spring\r\n                {\r\n                    // Make sure this isn't the first particle in the row, if there is, there won't be anything to it's left and we can't connect.\r\n                    //connects to the part we just created with the particle at the index.\r\n                    // particle at the same Y value.\r\n                    // x - 1 we're creating all the particles one by one, but storing.\r\n                    Spring sideSpring = Instantiate(spring);\r\n                    LineRenderer l = sideSpring.GetComponent<LineRenderer>();\r\n                    l.SetPosition(0, newParticle.transform.position);\r\n                    l.SetPosition(1, particles[y * width + (x - 1)].transform.position);\r\n                    sideSpring.name = \"SideSpring: \" + x.ToString() + \" \" + y.ToString();\r\n                    sideSpring.makeSpring(newParticle, particles[y * width + (x - 1)]);\r\n                    springs.Add(sideSpring);\r\n                    sideSpring.transform.SetParent(springs_.transform);\r\n                }\r\n\r\n                if (y > 0) // Up Spring\r\n                {\r\n                    //// Connecting ontop, but going downwards.\r\n                    Spring aboveSpring = Instantiate(spring);\r\n                    LineRenderer l = aboveSpring.GetComponent<LineRenderer>();\r\n                    l.SetPosition(0, newParticle.transform.position);\r\n                    l.SetPosition(1, particles[(y - 1) * width + x].transform.position);\r\n                    aboveSpring.name = \"AboveSpring: \" + x.ToString() + \" \" + y.ToString();\r\n                    aboveSpring.makeSpring(newParticle, particles[(y - 1) * width + x]);\r\n                    springs.Add(aboveSpring);\r\n                    aboveSpring.transform.SetParent(springs_.transform);\r\n                }\r\n\r\n                if (x > 0 && y > 0) // DownLeftDiagonal spring y-1, x-1\r\n                {\r\n                    Spring downLeftSpring = Instantiate(spring);\r\n                    LineRenderer l = downLeftSpring.GetComponent<LineRenderer>();\r\n                    l.SetPosition(0, newParticle.transform.position);\r\n                    l.SetPosition(1, particles[(y - 1) * width + (x - 1)].transform.position);\r\n                    downLeftSpring.name = \"UpLeftSpring: \" + x.ToString() + \" \" + y.ToString();\r\n                    downLeftSpring.makeSpring(newParticle, particles[(y - 1) * width + (x - 1)]);\r\n                    springs.Add(downLeftSpring);\r\n                    downLeftSpring.transform.SetParent(springs_.transform);\r\n                }\r\n\r\n                if (x < width - 1 && y > 0) // DownRightDiagonal, spring y-1, x+1\r\n                {\r\n                    Spring downRightSpring = Instantiate(spring);\r\n                    LineRenderer l = downRightSpring.GetComponent<LineRenderer>();\r\n                    l.SetPosition(0, newParticle.transform.position);\r\n                    l.SetPosition(1, particles[(y - 1) * width + (x + 1)].transform.position);\r\n                    downRightSpring.name = \"DownRightSpring: \" + x.ToString() + \" \" + y.ToString();\r\n                    downRightSpring.makeSpring(newParticle, particles[(y - 1) * width + (x + 1)]);\r\n                    springs.Add(downRightSpring);\r\n                    downRightSpring.transform.SetParent(springs_.transform);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Credit: Matthew Williamson\r\n        for(int x = 0; x < particles.Count; x++)\r\n        {\r\n            if (x + 1 < width * height && x + width < width * height && x + width + 1 < width * height)\r\n            {\r\n                AeroForce firstTri = Instantiate(triangle);\r\n                firstTri.name = \"FirstTriangle: \" + width.ToString() + \" \" + height.ToString();\r\n                firstTri.makeTriangle(particles[x], particles[x + 1], particles[x + width]);\r\n                triangles.Add(firstTri);\r\n                firstTri.transform.SetParent(triangle_.transform);\r\n\r\n                AeroForce secondTri = Instantiate(triangle);\r\n                secondTri.name = \"SecondTriangle: \" + width.ToString() + \" \" + height.ToString();\r\n                secondTri.makeTriangle(particles[x], particles[x + 1], particles[x + width + 1]);\r\n                triangles.Add(secondTri);\r\n                secondTri.transform.SetParent(triangle_.transform);\r\n\r\n                AeroForce thirdTri = Instantiate(triangle);\r\n                thirdTri.name = \"ThirdTriangle: \" + width.ToString() + \" \" + height.ToString();\r\n                thirdTri.makeTriangle(particles[x + 1], particles[x + width], particles[x + width + 1]);\r\n                triangles.Add(thirdTri);\r\n                thirdTri.transform.SetParent(triangle_.transform);\r\n\r\n                AeroForce fourthTri = Instantiate(triangle);\r\n                fourthTri.name = \"FourthTriangle: \" + width.ToString() + \" \" + height.ToString();\r\n                fourthTri.makeTriangle(particles[x], particles[x + width], particles[x + width + 1]);\r\n                triangles.Add(fourthTri);\r\n                fourthTri.transform.SetParent(triangle_.transform);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#File: Particle.cs\r\nclass Particle: \r\nusing UnityEngine;\r\nusing System.Collections;\r\n\r\npublic class Particle : MonoBehaviour\r\n{\r\n    public Vector3 position // current pos of the particle in space\r\n    {\r\n        get { return transform.position; }\r\n        set { transform.position = value; } // Getting and Setting the position = transform.position\r\n    }\r\n    public Vector3 velocity; // current velocity of the particle\r\n    public Vector3 force;\r\n    public float mass;\r\n    public bool isPinned;\r\n\r\n    void Awake()\r\n    {\r\n        position = transform.position;\r\n    }\r\n\r\n    public void ParticleMath()\r\n    {\r\n        if (!isPinned)\r\n        {\r\n            Vector3 acceleration = force / mass; // We create acceleration right here, so it doesn't get reset\r\n            velocity += (acceleration * Time.deltaTime);\r\n            position += (velocity * Time.deltaTime);\r\n        }\r\n    }\r\n}\r\n\r\n#File: Spring.cs\r\nclass Spring: \r\nusing UnityEngine;\r\nusing System.Collections;\r\n\r\npublic class Spring : MonoBehaviour\r\n{\r\n    public float springConstant;\r\n    public float dampingFactor;\r\n    public float RestLength;\r\n    public Particle p1, p2;\r\n    \r\n    public void makeSpring(Particle P1, Particle P2)\r\n    {\r\n        p1 = P1;\r\n        p2 = P2;\r\n    }\r\n\r\n    public void ComputeForce()\r\n    {\r\n        // Credit: Matthew Williamson.\r\n        Vector3 e = p2.position - p1.position;\r\n        Vector3 l = e.normalized;\r\n        float distanceBetween = Vector3.Distance(p1.position, p2.position);\r\n        float forceSpring = -springConstant * (RestLength - distanceBetween);\r\n        float v1 = Vector3.Dot(l, p1.velocity);\r\n        float v2 = Vector3.Dot(l, p2.velocity);\r\n        float dampingForce = -dampingFactor * (v1 - v2);\r\n        float springDamper = forceSpring + dampingForce;\r\n        Vector3 force1 = springDamper * l;\r\n        Vector3 force2 = -force1;\r\n\r\n        p1.force += force1;\r\n        p2.force += force2;\r\n    }\r\n}\r\n\r\n#File: AeroForce.cs\r\nusing UnityEngine;\r\nusing System.Collections;\r\n\r\npublic class AeroForce : MonoBehaviour\r\n{\r\n    Particle p1, p2, p3;\r\n    public Vector3 velAir = new Vector3 (0, 0, 0);\r\n    public float drag = 0.5f;\r\n    public float density = 1.0f;\r\n\r\n    public void makeTriangle(Particle P1, Particle P2, Particle P3)\r\n    {\r\n        p1 = P1;\r\n        p2 = P2;\r\n        p3 = P3;\r\n    }\r\n\r\n    public void AeroMath()\r\n    {\r\n        // Credit: Matthew Willson && Andrew Gotow.\r\n\r\n        //Find velocity of Triangle.\r\n        Vector3 velTriangle = (p1.velocity + p2.velocity + p3.velocity) / 3;\r\n\r\n        //Find relative velocity, so subtract off velocity of the air.\r\n        velTriangle -= velAir;\r\n\r\n        //Finding the normal of the Triangle.\r\n        Vector3 a = p2.position - p1.position;\r\n        Vector3 b = p3.position - p1.position;\r\n        Vector3 crossProduct = Vector3.Cross(a,b);\r\n        Vector3 normalTri = crossProduct / crossProduct.magnitude;\r\n        float totalArea = 0.5f * crossProduct.magnitude;\r\n        float effectiveArea = totalArea * Vector3.Dot(velTriangle, normalTri) / velTriangle.magnitude;\r\n\r\n        // Aerodyamic Force equation\r\n        // AeroForce = -0.5 * density * drag * area * |V|^2 * normalTri\r\n        Vector3 aeroForce = -0.5f * drag * density * effectiveArea * velTriangle.sqrMagnitude * normalTri;\r\n\r\n        aeroForce /= 3.0f;\r\n\r\n        p1.force += aeroForce;\r\n        p2.force += aeroForce;\r\n        p3.force += aeroForce;\r\n    }\r\n}\r\n\r\n#File: DragObject.cs\r\nusing UnityEngine;\r\nusing System.Collections;\r\n\r\npublic class DragObject : MonoBehaviour\r\n{\r\n    private Vector3 screenPoint;\r\n    private Vector3 offset;\r\n\r\n    private void OnMouseDown()\r\n    {\r\n        //translate the particle position from the world to Screen Point\r\n        screenPoint = Camera.main.WorldToScreenPoint(gameObject.transform.position);\r\n        //calculate any difference between the particle world position and the mouses Screen position converted to a world point  \r\n        offset = gameObject.transform.position - Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, screenPoint.z));\r\n    }\r\n\r\n    private void OnMouseDrag()\r\n    {\r\n        //keep track of the mouse position\r\n        Vector3 currentScreenPoint = new Vector3(Input.mousePosition.x, Input.mousePosition.y, screenPoint.z);\r\n        //convert the screen mouse position to world point and adjust with offset\r\n        Vector3 currentPosition = Camera.main.ScreenToWorldPoint(currentScreenPoint) + offset;\r\n        //update the position of the object in the world\r\n        transform.position = currentPosition;\r\n    }\r\n}\r\n\r\n#File: SetText.cs\r\nusing UnityEngine;\r\nusing UnityEngine.UI;\r\n\r\npublic class SetText : MonoBehaviour\r\n{\r\n    public void SetLabel(Slider slider)\r\n    {\r\n        gameObject.GetComponent<Text>().text = slider.value.ToString();\r\n    }\r\n}\r\n\r\nIV.2: Operating Directions\r\nTo run this program, navigate through directory and click on build.exe or go to http://paulchu756.github.io/Physics/  (Please make sure you have build data folder with it).\r\n\r\nV.0: Instructions\r\nLeft click: drag particles around in the scence.\r\nRight Click: rotate the camera on any axis(It is slow). \r\nMiddle Mouse Button: To translate on x and y axis. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}